\chapter{Analisi e Conclusioni}
\label{cha:intro}
\vspace{5mm}

Per discutere di ciò che il refactor ha portato dividerò le conclusioni in due parti prendendo in considerazione prima il lato tecnologico e poi il lato umano. Ponendo che il progetto è in fase di terminazione non vi è la possibilità di accedere a dati definitivi per cui quello che riporterò di seguito potrebbero essere soggetto a variazioni future.

\vspace{5mm} Previa analisi è necessario fornire un contesto per qualificare al meglio i dati che andrò a descrivere, il primo fattore sono il numero di sviluppatori dedicati a questo progetto. La composizione dell'organico è il seguente, un grafico, due programmatori ed un project manager il quale compito era gestire la qualità del prodotto e far rispettare le tempistiche promesse al cliente.

\vspace{5mm}Prendendo in considerazione il lato umano è subito risultato lampante come, seppur la divisione dei compiti dello sviluppo era fatta per ambienti e cioè lato client e lato server, la facilità con cui il team ha potuto interscambiarsi è stata molto evidente. Si è mostrato come, seppur la codebase fosse nuova e solo la logica generale fosse conosciuta, possedere una 'lingua franca' in cui esprimersi è stato fondamentale per velocizzare tutte quelle operazioni che richiedevano di muoversi in un differente. Un altro esempio di questo è la velocità con cui si sono eseguite le code review settimanali. Possedere un dialetto comune permette di rendere più veloce la comprensione delle features aggiunte dal collega e trovare eventuali bug o problemi in modo più immediato. Ecco che grazie a questo tipo di approccio si è potuto delineare una tecnica di divisione dei compiti non più per zona di lavoro (server o client) ma per funzionalità. Si è notato che la velocità di sviluppo aumentava se, isolata una features, chi aveva il compito di implementarla creava sia il lato client che il lato server. Questo ha evitato anche lo sviluppo di rest api ridondanti con dati mai utilizzati a front end, aumentando l'efficenza del software, evitando di dover eseguire lo step intermedio di accordarsi, per ogni nuova funzionalità che si andava ad inserire, sulla forma delle api. Ora di fatto chi sviluppa la funzionalità lato utente ha anche il compito di sviluppare le api che dovranno essere consumate per fornire tale funzionalità creando un prodotto meno frammentato e più integrato. 

\vspace{5mm}Un altro punto focale è stata la possibilità di condividere conoscenze in modo più diretto. Molte delle tecnologie e dei pattern di programmazione utilizzati principalmente a lato client hanno contaminato il lato server e vice versa. Librerie come Redux sono agnostiche e possono adattarsi facilmente al contesto server e pattern come la programmazione funzionale possono essere distribuite senza difficoltà nell'intera codebase del progetto evitando "l'effetto palude". Tale effetto è quando durante lo sviluppo una parte di codice non mantenuta diventa ingestibile a causa dell'incapacità dei colleghi di fare refactor su quella parte perché scritta con un certo linguaggio non conosciuto da tutti i componenti del team, o con un pattern conosciuto solamente dal suo scrittore. Con uno stack full Javascript come quello proposto nella soluzione descritta in questa tesi si può risolvere senza overhead questo genere di problemi forzando un vero standard in tutta la code base superando i limiti tecnologici imposti da un cambio di linguaggio tra due aree.

\vspace{5mm}Ulteriore appunto che è emerso durante lo sviluppo è stata la possibilità di condividere alcune logiche tra client e server, tagliando notevolmente i tempi di sviluppo. Tutte le logiche per il recupero dei dati sono state racchiuse in una piccola libreria che è stata condivisa tra gli applicativi mobili e il lato admin. La scrittura di un solo pezzo di codice destinato ad uno scopo preciso e portabile su più piattaforme ha inoltre evitato bug derivati da modifiche alle api dato che per più volte è bastato aggiornare internamente la libreria senza dover cambiare null'altro.

\vspace{5mm}Un ultimo punto che voglio includere che non è legato ad una situazione generica ma solamente al mio ambiente lavorativo; essendo Farnedi ICT in primis un azienda che fa supporto tecnico ad aziende e p.a. parte dei suoi dipendenti non hanno una conoscenza diretta di sviluppo software. Javascript è risultato essere molto chiaro anche a chi è al di fuori del campo, permettendo anche al lato manageriale di entrare, in minima parte, nello sviluppo. Tale considerazione potrebbe essere legata alla mia sola realtà aziendale ma è stata di grande importanza per la produzione di funzionalità qualitativamente più in linea con le richieste del direttivo.

\vspace{5mm}Dal punto di vista tecnologico non vi sono stati cambiamenti importanti, le funzionalità applicative trattandosi di un refactor hanno seguito la linea del prodotto iniziale. Però la dismessa di un applicativo come filemaker per il recupero dei dati è stata la fonte di un incremento sostanziale nella mantenibilità e nella rapidità dell'applicativo in tutte le sue parti. La scelta di passare da un applicativo sviluppato con un framework proprietario ad un tool open source come React ha portato in generale ad ottenere un ambente di sviluppo più moderno e flessibile. Il passaggio ad una SPA\cite{SPA} ha migliorato non solo l'esperienza per chi ha sviluppato il software ma la qualità del prodotto in se.

\section{Problematiche}
\vspace{5mm}L'utilizzo di una sola tecnologia in più zone distinte dello stack porta con se numerosi vantaggi che ho descritto precedentemente. Va detto però che se nello specifico caso applicativo preso da me come esempio le tecnologie Javascript esistenti sul mercato andavano a completare in modo ottimale le necessità applicative, questo può non essere vero per tutti i casi. In linea generale è sempre meglio scegliere la tecnologia migliore per la funzionalità che si vuole svolgere. Un esempio è la capacità computazionale limitata di Javascript che a confronto con Python non permette di svolgere in modo efficiente operazioni su matrici limitandone l'uso per quanto riguarda l'ambito del machine learning. In questo caso Javascript potrebbe far eseguire le operazioni di calcolo sfruttando l'ambiente fornito da Node e in particolare eseguire dei processi stando in ascolto di essi, in attesa di risultati sfruttando l'asicronicità dell'I/O fornita dal framework. Tali processi, disegnati per eseguire micro task di computazione matematica, potrebbero essere sviluppati in c o c++ in modo da essere il più ottimizzati possibile per il compito. Tale approccio però offre il fianco ad una serie di problematiche legate alla mantenibilità della parte in c++ e alla dipendenza non diretta del software Javascript a tale libreria. Per avere questo tipo di dipendenza è necessario crearla attraverso una struttura software per interrompere l'esecuzione o mostrare degli errori all'avvio in caso tali dipendenze non siano esplicitate.
