\chapter{Analisi e Conclusioni}
\label{cha:intro}
\vspace{5mm}

Per discutere di ciò che il refactor ha portato dividerò le conclusioni in due parti prendendo in considerazione prima il lato tecnologico e poi il lato umano. Ponendo che il progetto è in fase di terminazione non vi è la possibilità di accedere a dati definitivi per cui quello che riporterò di seguito potrebbero essere soggetto a variazioni future.\vspace{5mm}

 Previa analisi è necessario fornire un contesto per qualificare al meglio i dati che andrò a descrivere, il primo fattore sono il numero di sviluppatori dedicati a questo progetto. La composizione dell'organico è il seguente, un grafico, due programmatori ed un project manager il quale compito era gestire la qualità del prodotto e far rispettare le tempistiche promesse al cliente.\vspace{5mm}

Prendendo in considerazione il lato umano è subito risultato lampante come, seppur la divisione dei compiti dello sviluppo era fatta per ambienti e cioè lato client e lato server, la facilità con cui il team ha potuto interscambiarsi è stata molto evidente. Si è mostrato come, seppur la codebase fosse nuova e solo la logica generale fosse conosciuta, possedere una 'lingua franca' in cui esprimersi è stato fondamentale per velocizzare tutte quelle operazioni che richiedevano di muoversi in un differente. Un altro esempio di questo è la velocità con cui si sono eseguite le code review settimanali. Possedere un dialetto comune permette di rendere più veloce la comprensione delle features aggiunte dal collega e trovare eventuali bug o problemi in modo più immediato. Ecco che grazie a questo tipo di approccio si è potuto delineare una tecnica di divisione dei compiti non più per zona di lavoro (server o client) ma per funzionalità. Si è notato che la velocità di sviluppo aumentava se, isolata una features, chi aveva il compito di implementarla creava sia il lato client che il lato server. Questo ha evitato anche lo sviluppo di rest api ridondanti con dati mai utilizzati a front end, aumentando l'efficenza del software, evitando di dover eseguire lo step intermedio di accordarsi, per ogni nuova funzionalità che si andava ad inserire, sulla forma delle api. Ora di fatto chi sviluppa la funzionalità lato utente ha anche il compito di sviluppare le api che dovranno essere consumate per fornire tale funzionalità creando un prodotto meno frammentato e più integrato. \vspace{5mm}

Un altro punto focale è stata la possibilità di condividere conoscenze in modo più diretto. Molte delle tecnologie e dei pattern di programmazione utilizzati principalmente a lato client hanno contaminato il lato server e vice versa. Librerie come Redux sono agnostiche e possono adattarsi facilmente al contesto server e pattern come la programmazione funzionale possono essere distribuite senza difficoltà nell'intera codebase del progetto evitando "l'effetto palude". Tale effetto è quando durante lo sviluppo una parte di codice non mantenuta diventa ingestibile a causa dell'incapacità dei colleghi di fare refactor su quella parte perché scritta con un certo linguaggio non conosciuto da tutti i componenti del team, o con un pattern conosciuto solamente dal suo scrittore. Con uno stack full Javascript come quello proposto nella soluzione descritta in questa tesi si può risolvere senza overhead questo genere di problemi forzando un vero standard in tutta la code base superando i limiti tecnologici imposti da un cambio di linguaggio tra due aree.\vspace{5mm}

Ulteriore appunto che è emerso durante lo sviluppo è stata la possibilità di condividere alcune logiche tra client e server, tagliando notevolmente i tempi di sviluppo. Tutte le logiche per il recupero dei dati sono state racchiuse in una piccola libreria che è stata condivisa tra gli applicativi mobili e il lato admin. La scrittura di un solo pezzo di codice destinato ad uno scopo preciso e portabile su più piattaforme ha inoltre evitato bug derivati da modifiche alle api dato che per più volte è bastato aggiornare internamente la libreria senza dover cambiare null'altro.\vspace{5mm}

Un ultimo punto che voglio includere che non è legato ad una situazione generica ma solamente al mio ambiente lavorativo; essendo Farnedi ICT in primis un azienda che fa supporto tecnico ad aziende e p.a. parte dei suoi dipendenti non hanno una conoscenza diretta di sviluppo software. Javascript è risultato essere molto chiaro anche a chi è al di fuori del campo, permettendo anche al lato manageriale di entrare, in minima parte, nello sviluppo. Tale considerazione potrebbe essere legata alla mia sola realtà aziendale ma è stata di grande importanza per la produzione di funzionalità qualitativamente più in linea con le richieste del direttivo.\vspace{5mm}

Dal punto di vista tecnologico non vi sono stati cambiamenti importanti, le funzionalità applicative trattandosi di un refactor hanno seguito la linea del prodotto iniziale. Però la dismessa di un applicativo come filemaker per il recupero dei dati è stata la fonte di un incremento sostanziale nella mantenibilità e nella rapidità dell'applicativo in tutte le sue parti. La scelta di passare da un applicativo sviluppato con un framework proprietario ad un tool open source come React ha portato in generale ad ottenere un ambente di sviluppo più moderno e flessibile. Il passaggio ad una SPA\cite{SPA} ha migliorato non solo l'esperienza per chi ha sviluppato il software ma la qualità del prodotto in se.\vspace{5mm}

Per quanto riguarda i costi di refactor degli applicativi è risultato in un consumo di ore uomo differente a seconda dell'ambito del refactor. Nel caso dell'applicativo admin lo sviluppo è stato più costoso in ore lavoro rispetto alla versione precedente in Filemaker ma, ciò ha tolto ulteriore lavoro necessario per adattare i dati provenienti da filemaker alla struttura del database. Per quanto riguarda invece lo sviluppo degli applicativi mobili React-native ha portato un enorme vantaggio riducendo alle versioni divise, infatti lo sviluppo necessario per il completaemnto di entrambe le versioni è stato un terzo rispetto al precedente.\vspace{5mm}  

\section{Confronto tra le due versioni}\vspace{5mm}  

Confrontando gli stack delle due applicazioni in termini di tecnologie utilizzate possiamo vedere i motivi per cui le scelte fatte migliorano il software e sotto quali aspetti. \vspace{5mm}

Grazie all'utilizzo del medesimo framework lato mobile e lato web è stato possibile condividere gran parte del codice e delle logiche di interazione con le api lato server. Un altra zona di condivisione è l'implementazione di Redux. Data la sua agnosticità sulla piattaforma utilizzata questa libreria è un perfetto esempio di come l'utilizzo di uno stack basato interamente su Javascript porti ad un riutilizzo del codice in modo importante ma sopratutto in modi impraticabili precedentemente. In particolare tra l’applicativo admin sviluppato come webapp per il browser e gli applicativi nativi ho condiviso la totalità dell’implementazione gestendo lo store allo stesso modo. Le differenze principali sono sulla libreria che permette di interfacciarsi con le api lato server. Seppur molti metodi sono condivisi, quelli relativi alla mutazione dei dati sono riserveti ai soli utenti autenticati e cioè Admin. Tale peculiarità però non influisce nella possibilità di riutilizzare parte della libreria che implementa sia i metodi lato amministratore che quelli lato utente senza privilegi.\vspace{5mm} 

Un ulteriore punto è che rispetto alla versione precedente vi è una somiglianza molto forte tra quello che è l’applicativo web e l’applicativo nativo, le due applicazioni non sono compatibili ma condividono gran parte delle logiche e dei pattern essendo di fatto lo stesso framework. Ciò permette di avere un livello di complessità all'approccio a questo progetto più bassa della versione precedente. Questo porta a tempi più corti per l'apprendimento dei pattern e delle logiche e di conseguenza risulta in una miglior produttività.\vspace{5mm}
	
La scelta dell’utilizzo di un database a file con la possibilità di configurare e passare ad un database “classico” si è rivelata molto importante per la scalabilità dell’applicativo. SqLite risulta più comodo in fase di deploy di contro, non ha le prestazioni di un database “classico” e la possibilità di configurare rapidamente la tecnologia da utilizzare è un plus importante. Questo si ottiene grazie all’impiego di un ORM in grado di fornire questa features come Sequelize. Oltre a questo permette di implementare in modo veloce migrazioni e seeder restando sempre agnostico sulla tecnologia a database. La versione precedente conteneva una pesante assunzione sull’utilizzo di un database MySql e ciò abbassava sostanzialmente la flessibilità e il riutilizzo del prodotto.\vspace{5mm}

Un altra differenza rispetto alla precedente è l’esistenza dell’applicativo admin in react che dovrà essere servito dall’applicativo server. Per fare questo è necessario che tutte le richieste non inviate direttamente a /api, vengano tutte reindirizzare all’applicativo in modo che la SPA utilizzi il router interno a React per mostrare i contenuti corrispondenti all’url della richiesta.\vspace{5mm}

Riguardo al lato “admin”, cioè quello che va a sostituire Filemaker nella raccolta dati, è stato sviluppato con React. La scelta di sviluppare una SPA\cite{SPA} per questo compito è stata dettata da un bisogno di rendere questa operazione iterabile e ripetibile. Nel caso in cui il cliente volesse cambiare dei testi o correggere delle traduzioni può farlo in autonomia, senza dover passare da una figura che traduca le modifiche richieste aggiungendole a database manualmente. Questo processo inoltre astrae ulteriormente la struttura del database durante il processo di inserimento dei dati offrendo quindi flessibilità su modifiche future alla struttura. Un altro punto a favore della scelta di una SPA \vspace{5mm}

\section{Punti critici}
\vspace{5mm}L'utilizzo di una sola tecnologia in più zone distinte dello stack porta con se numerosi vantaggi che ho descritto precedentemente. Va detto però che se nello specifico caso applicativo preso da me come esempio le tecnologie Javascript esistenti sul mercato andavano a completare in modo ottimale le necessità applicative, questo può non essere vero per tutti i casi. In linea generale è sempre meglio scegliere la tecnologia migliore per la funzionalità che si vuole svolgere. Un esempio è la capacità computazionale limitata di Javascript che a confronto con Python non permette di svolgere in modo efficiente operazioni su matrici limitandone l'uso per quanto riguarda l'ambito del machine learning. In questo caso Javascript potrebbe far eseguire le operazioni di calcolo sfruttando l'ambiente fornito da Node e in particolare eseguire dei processi stando in ascolto di essi, in attesa di risultati sfruttando l'asicronicità dell'I/O fornita dal framework. Tali processi, disegnati per eseguire micro task di computazione matematica, potrebbero essere sviluppati in c o c++ in modo da essere il più ottimizzati possibile per il compito. Tale approccio però offre il fianco ad una serie di problematiche legate alla mantenibilità della parte in c++ e alla dipendenza non diretta del software Javascript a tale libreria. Per avere questo tipo di dipendenza è necessario crearla attraverso una struttura software per interrompere l'esecuzione o mostrare degli errori all'avvio in caso tali dipendenze non siano esplicitate.

\vspace{5mm}La scelta di utilizzare un database a file per conservare i dati sui vari punti rende problematico scalare il prodotto. Infatti, nel caso si voglia far pilotare questo applicativo da un loadbalancer\cite{LoadBalancing} in grado di animare istanze a seconda del carico, ogni istanza non sarà in grado di condividere dati tra di essa creando un grave problema di consistenza. Per questa ragione la scelta di utilizzare questo tipo di tecnologia è fallimentare in quest'ottica. Una soluzione per dare la possibilità di scalare all'applicativo è quella di sfruttare la flessibilità di Sequelize\cite{Sequelize} che permette di mantenere la stessa struttura dei modelli ma di cambiare la tecnologia del database. E' grazie a questa astrazione software che si è in grado di adattare il nuovo applicativo ad altri contesti di utilizzo.









