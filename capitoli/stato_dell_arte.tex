\chapter{Stato dell'arte}
\label{cha:intro}
\vspace{5mm}
\emph{Questo capitolo descrive le varie tecnologie Javascript disponibili sul mercato e in che modo possono essere combinate per costruire il nuovo stack applicativo.}
\section{Javascript}\vspace{5mm}
Javascript è nato come linguaggio di scripting lato client e ha man mano preso piede come uno dei più flessibili e dinamici, diventando uno standard dei browser moderni dichiarando la morte di progetti come Netscape Navigator.\vspace{5mm}

Nel 2009 un ragazzo di nome Ryan Dahl presentò alla JSConf Node Js. Ciò che propose Ryan era quello di utilizzare Javascript come linguaggio lato server utilizzando una strategia simile a quella di Java con la JVM quindi sviluppando un layer di api per utilizzare le risorse del sistema operativo combinato con la flessibilità e la comodità di un linguaggio interpretato.\vspace{5mm}

La vera novità era che per scrivere un applicativo web non bisognava più conoscere due linguaggi (Javascript client e PHP, Java, Python, ecc… server) ma ne bastava uno. Inizialmente la risposta fu tiepida e Node Js rischiò più volte di essere abbandonato, ma con il crescere sempre maggiore della stabilità del framework e la fondazione della Node.js Foundation ad ora è una delle 4 maggiori tecnologie di sviluppo al mondo. L’avvento di questa tecnologia ha incubato una miriade di prodotti diversi dando vita a uno degli ecosistemi più grandi e variegati mai esistiti.\vspace{5mm}

\subsection{ Frameworks Javascript}\vspace{5mm}

	L’ecosistema Javascript per il web è molto ricco di soluzioni per tutti gli ambiti di impiego. Per quanto riguarda il lato applicativo front-end vi sono numerose scelte, sia che si intenda operare nel browser che fuori da esso. I principali framework per lo sviluppo web front-end sono React, AngularJs, Vue e Ember. I primi tre implementano il pattern MVC “Model-View-Controller” ovvero la separazione di ciò che detiene i dati da ciò che li renderizza all’utente attraverso una logica che fa da moderatore del flusso. Sia Angular che Vue che Ember offrono nativamente “two-way data binding” ovvero la capacità di mantenere in sincronia tra View e Model. React d’altro canto è stato pensato per essere una libreria e non come un vero e proprio framework infatti il suo approccio è puramente legato alla costruzione dell’interfaccia grafica slegata da quelle che sono tutte le implementazioni possibili nella gestione e nel flusso dei dati. \vspace{5mm}

Nel caso di applicativi complessi che devono gestire molti dati, questa parte può risultare complessa e particolarmente sensibile a bug. Per questo, soluzioni come Redux possono risultare funzionali a tale scope implementativo. Lo scopo di tale libreria è quello di contenere lo stato-applicativo e fare in modo che sia sempre in uno stato certo e consistente permettendo la modifica di esso solo attraverso delle “Action”. Ad ogni “Action” o azione corrisponde una tipologia che il reducer interpreta per modificare lo stato di conseguenza. Il reducer è una funzione pura che prende in input lo stato attuale e l’azione eseguita su di esso e ritorna il nuovo stato applicativo. Essendo i reducer funzioni pure sono prevedibili, prive di “Side effects” e facilmente testabili.\vspace{5mm} 

Per quanto riguarda la parte applicativa per le due piattaforme mobili le scelte possibili sono racchiuse in Cordova/Phonegap, Ionic e React-native. I primi due sono dei “wrap” attorno ad una webView nativa con una serie di Api rese disponibili a Javascript che gira all’interno del browser che risiede nella webView. Tale soluzione è seppur funzionale, non ottimale per il caso d’uso specifico; infatti l’applicativo Alakai necessità di avere accesso al bluetooth e ad altre Api non disponibili negli ambienti di Cordova/PhoneGap. Da notare che Ionic, seppur basato sulla medesima tecnologia mette a disposizione delle Api per interagire in modo completo con il bluetooth, questo e la sua maturità lo rendono un'ottima scelta per sviluppare la parte mobile dell’applicativo.\vspace{5mm} 

D’altro canto React-native è framework basato sull’utilizzo di un motore di compilazione che non fa altro che prendere i costrutti Javascript dichiarati utilizzando librerie e convertirli in codice nativo, a seconda della piattaforma. Inoltre permette, se necessario di interfacciarsi con l’ambiente nativo a piacimento dando la possibilità di utilizzare un costrutto chiamato “bridge” che offre un’interfaccia a Javascript verso il nativo e viceversa. La differenza principale tra i sistemi che usano Cordova e React-native è che il primo ha come goal quello di “Write once run everywhere” mentre il secondo è “Learn once use everywhere”.\vspace{5mm}

Per la parte server vi sono disponibili anche qui diverse scelte e tecnologie, seppur orientate alla stessa soluzione molto diverse tra di loro. Vi sono librerie come Express js che sono pensate per essere molto leggere e di lieve impatto nella strutturazione dei dati. Di contro ve ne sono altre che offrono un profondo controllo su tutti gli aspetti dell’applicativo come MeteorJs e Sails Js che offrono una serie di features come la generazione automatica di Api seguendo la specifica delle “CROUD operation”, la generazione automatica di modelli per descrivere nuove entità e la gestione automatica dell’autenticazione e la gestione degli utenti.\vspace{5mm}

\section{Audioguide}\vspace{5mm}

Vi sono disponibili diversi prodotti che offrono la possibilità di creare audioguide per determinate zone o città. Alcuni di questi utilizzano un approccio di “selezione luogo” e cioè chi utilizza l’applicativo deve prima indicare a quale zona è interessato per poi essere reindirizzato alla sezione relativa a quell’area geografica. Altri prodotti come Open Air Museum utilizzano un approccio “mono scopo” e cioè l’audioguida è relativa ad una sola area specifica e sviluppata ad Hoc per quello scopo. L’approccio descritto per primo permette di dover mantenere un solo prodotto e di servire molteplici enti, questo però limita molto la customizzazione che tali applicativi possono possedere. Di contro il secondo approccio permette una customizzazione elevata, essendo il prodotto sviluppato appositamente per l’ente; questo però comporta un overhead non indifferente per chi mantiene tale applicativo. Infatti se si vogliono servire un gran numero di realtà risulta dispendioso dover gestire e mantenere molti applicativi diversi, ognuno con le sue peculiarità e caratteristiche.\vspace{5mm}

Un ulteriore punto di riflessione sono le funzionalità. La totalità dei competitor presi in considerazione permette di visualizzare contenuti multimediali collegati a punti di interesse o percorsi, ma in pochi offrono un servizio di localizzazione attivo a guidare all’interno della zona di interesse. La totalità degli applicativi presi in considerazione che hanno questa features utilizzano come tecnologia di localizzazione il gps che per zone all’aperto, come lo possono essere città o parchi naturali, è un ottima soluzione; però per quanto riguarda la localizzazione indoor come in un museo per esempio, risulta imprecisa e poco utilizzabile. IBeacon in questo caso risulta la tecnologia migliore per localizzazione degli utenti dato che non deve fare affidamento a triangolazioni satellitari.\vspace{5mm}

Quello che offrirà al nuova versione di Open Air Museum è un approccio misto rispetto a quello descritto all’inizio di questo capitolo, ciò che si andrà a realizzare andrà a rientrare nella categoria “mono scopo” ma grazie all’elevata flessibilità delle impostazioni di avvio sarà possibile customizzare in modo profondo l’applicativo mantenendo allo stesso tempo una documentazione esplicita sulle proprie features. Infatti il file di configurazione è in formato json quindi facilmente accessibile sia ad umani sia a computer. ---- spiega meglio.\vspace{5mm}


[PUOI DIRE ALTRO?] \vspace{5mm}

prendi spunto da "Cross-platform data-driven applications with React Native and GraphQL: Principles and practices" !!!!!!

