\chapter{Strumenti e tecnologie}
\label{cha:intro}
\vspace{5mm}

\emph{Questo capitolo descrive in maniera più approfondita le tecnologie utilizzate nella prima e nella seconda versione in un confronto dettagliato.}

\section{Presentazioni delle tecnologie utilizzate in Open Air Museum}\vspace{5mm}
Indicherò le varie tecnologie utilizzate per l'attuale versione dell'applicativo.

\vspace{5mm}Filemaker: E’ una piattaforma per creare applicativi personalizzati votati alla categoria “gestionale” sviluppata da Apple. Open Air Museum utilizza questa tecnologia per creare l’interfaccia per la raccolta dati che verrà utilizzata da alcuni addetti comunali che appunto arricchiranno l’applicativo con i testi e i media provenienti da questo software. Tale applicativo è standalone e quindi slegato dall’applicativo lato server che espone le Api e l’importazione dei dati provenienti da questa soluzione deve essere fatta manualmente. Ciò comporta uno svantaggio non indifferente che preclude una scalabilità rapida del prodotto. La scelta di questa tecnologia era quella di avere il più rapidamente possibile un prodotto in grado di iniziare a raccogliere dati il prima possibile e qualunque altra soluzione, seppur migliore in un ottica futura, avrebbe impiegato maggior tempo di sviluppo.\vspace{5mm}

	NodeJs: E’, come descritto in precedenza, un runtime di Javascript al di fuori del browser.Tale programma, come dicuterò più avanti, utilizza Chrome V8\cite{V8} come motore per eseguire Javascript ed grazie ciò NodeJs è stato fornito di una suite di interfacce per la comunicazione con l'hardware. In particolare questa particolare implementazione viene indicata come I/O non bloccante\cite{AsincIO}. La particolarità di questa soluzione è che mette a disposizione una serie di Api a basso livello che permettono di utilizzare la scheda di rete e quindi di avviare server TCP e HTTP oltre che accesso al file system quindi lettura e scrittura su disco. In Open air museum questo framework è utilizzato per costruire il lato server ed esporre una serie di Api Http Rest che permettono la fruizione dei dati. Tutti i media, quindi audio e immagini vengono serviti anch’essi da questa piattaforma che oltre a questo gestisce anche l’autenticazione degli utenti e la gestione degli stessi. \vspace{5mm}

	Xcode: Ide per lo sviluppo IOS. L’applicativo per tale sistema operativo è stato sviluppato in Swift4.\vspace{5mm}

	Android Studio: Ide per lo sviluppo Android. L’applicativo per tale sistema operativo è stato sviluppato in Java per android.\vspace{5mm}

	MySql/SqLite: Sono le tecnologie che utilizzano i due database relazionali di cui il prodotto è fornito. Tutti i dati lato server sono contenuti in un database MySql che viene pilotato tramite l’applicativo lato server in Nodejs. Entrambi i database lato client utilizzano invece SqLite. Lo schema relazionale per il lato server è il seguente, si vedano gli allegati per i due schemi ER corrispondenti.\vspace{5mm}
	
	/// schema er vecchio
	
\section{Presentazione delle tecnologie utilizzabili in Alakai}\vspace{5mm}
Indicherò le varie tecnologie utilizzate per la nuova versione dell'applicativo ponendo particolare attenzione a che vantaggi portano.\vspace{5mm}

React: Libreria Javascript per lo sviluppo di interfacce grafiche a componenti, permette lo sviluppo di single page application (SPA). In Alakai l’applicativo che permette l’inserimento dei dati e dei media oltre alle descrizioni dei punti di interesse e dei percorsi è creata utilizzando questa tecnologia sfruttando un set di Api che il lato server fornisce. Questo centralizza la gestione dei dati in un unico luogo e cioè il server, tale approccio permette di utilizzare l'applicativo backend come unica fonte di verità senza dover gestire due prodotti separati come vi era in precedenza\vspace{5mm}

	Redux: Libreria Javascript che permette di gestire lo stato applicativo come un unico oggetto statico, modificabile soltanto attraverso della azioni ben definite applicate ad esso. Ogni modifica viene fatta attraverso una funzione pura\cite{PureFunction} chiamata reducer che modifica a seconda dell'implementazione una parte specifica dello store. La firma di tale funzione prende due parametri, il primo è l'oggetto che rappresenta lo stato attuale dell'applicativo, il secondo è ciò che rappresenta l'azione che si sta compiendo. Tale azione dovrà sempre possedere una tipologia mentre può o non può avere un payload di dati che si riferiscono a quell'azione specifica. Ciò che ritornerà il reducer sarà un oggetto che diventerà il nuovo stato applicativo. Questa tecnologia è utilizzata per gestire i dati che gli applicativi mobile recupereranno dal server in modo predittivo e sicuro. Tale implementazione permette di evitare side effects\cite{SideEffects} nello stato applicativo facendo si che l'unica fonte di verità sia sempre affidabile e prevedibile. \vspace{5mm}
	
	/// schema store redux\vspace{5mm}

	React-Native: Implementazione di React ma per l’ambiente nativo. Questa tecnologia verrà usata per creare l’interfaccia e la logica degli applicativi IOS e Android. Tale scelta infatti permette di condividere buona parte del codice tra le due piattaforme.\vspace{5mm}

	Express: Implementazione del pattern middleware per Node Js. Tale framework permette di gestire con granularità il routing delle Api e da la possibilità di centralizzare la gestione degli errori. L'implementazione di tale pattern si riflette in un applicativo che esegue le computazioni attraverso una cascata di funzioni chiamate una dopo l'altra in ordine, ed ognuna di esse ha la facoltà di decidere se continuare la catena o interrompere la computazione. Questo permette di avere una struttura affidabile per gestire il routeing delle Rest api rendendo molto veloce e predittivo lo sviluppo.\vspace{5mm}
	
	/// Schema middleware a cascata per auth lato server\vspace{5mm}

	SqLite: “File-based” database utilizzato lato server per il salvataggio delle informazioni fornite dagli utenti admin attraverso l’applicativo web per la raccolta dei dati. Tale scelta è stata fatta per la flessibilità di questa tecnologia che permette di gestire internamente all’applicativo la creazione dello stesso e non attraverso una dipendenza esterna. Questo è stato fatto per semplificare ulteriormente il deploy eliminando le necessità di aggiungere una configurazione ulteriore all’ambiente.\vspace{5mm}
	
	/// schema er nuovo
	
	\vspace{5mm}Ora descriverò brevemente il nuovo schema logico dell'applicativo e come le varie tecnologie, tutte basate su Javascript interagiscono fra loro.\vspace{5mm}
	Come si può vedere in figura

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{images/stackAlakai.png}
\caption{Schema stack nuova versione}
\end{figure}

\section{Confronto tra la nuova e la vecchia versione}\vspace{5mm}
Confrontando gli stack delle due applicazioni in termini di tecnologie utilizzate possiamo vedere i motivi per cui le scelte fatte migliorano il software e sotto quali aspetti. \vspace{5mm}

Grazie all'utilizzo del medesimo framework lato mobile e lato web è stato possibile condividere gran parte del codice e delle logiche di interazione con le api lato server. Un altra zona di condivisione è l'implementazione di Redux. Data la sua agnosticità sulla piattaforma utilizzata questa libreria è un perfetto esempio di come l'utilizzo di uno stack basato interamente su Javascript porti ad un riutilizzo del codice in modo importante ma sopratutto in modi impraticabili precedentemente. In particolare tra l’applicativo admin sviluppato come webapp per il browser e gli applicativi nativi ho condiviso la totalità dell’implementazione gestendo lo store allo stesso modo. Le differenze principali sono sulla libreria che permette di interfacciarsi con le api lato server. Seppur molti metodi sono condivisi, quelli relativi alla mutazione dei dati sono riserveti ai soli utenti autenticati e cioè Admin. Tale peculiarità però non influisce nella possibilità di riutilizzare parte della libreria che implementa sia i metodi lato amministratore che quelli lato utente senza privilegi.\vspace{5mm} 

Un ulteriore punto è che rispetto alla versione precedente vi è una somiglianza molto forte tra quello che è l’applicativo web e l’applicativo nativo, le due applicazioni non sono compatibili ma condividono gran parte delle logiche e dei pattern essendo di fatto lo stesso framework. Ciò permette di avere un livello di complessità all'approccio a questo progetto più bassa della versione precedente. Questo porta a tempi più corti per l'apprendimento dei pattern e delle logiche e di conseguenza risulta in una miglior produttività.\vspace{5mm}
	
La scelta dell’utilizzo di un database a file con la possibilità di configurare e passare ad un database “classico” si è rivelata molto importante per la scalabilità dell’applicativo. SqLite risulta più comodo in fase di deploy di contro, non ha le prestazioni di un database “classico” e la possibilità di configurare rapidamente la tecnologia da utilizzare è un plus importante. Questo si ottiene grazie all’impiego di un ORM in grado di fornire questa features come Sequelize. Oltre a questo permette di implementare in modo veloce migrazioni e seeder restando sempre agnostico sulla tecnologia a database. La versione precedente conteneva una pesante assunzione sull’utilizzo di un database MySql e ciò abbassava sostanzialmente la flessibilità e il riutilizzo del prodotto.\vspace{5mm}

Un altra differenza rispetto alla precedente è l’esistenza dell’applicativo admin in react che dovrà essere servito dall’applicativo server. Per fare questo è necessario che tutte le richieste non inviate direttamente a /api, vengano tutte reindirizzare all’applicativo in modo che la SPA utilizzi il router interno a React per mostrare i contenuti corrispondenti all’url della richiesta.\vspace{5mm}

Riguardo al lato “admin”, cioè quello che va a sostituire Filemaker nella raccolta dati, è stato sviluppato con React. La scelta di sviluppare una SPA\cite{SPA} per questo compito è stata dettata da un bisogno di rendere questa operazione iterabile e ripetibile. Nel caso in cui il cliente volesse cambiare dei testi o correggere delle traduzioni può farlo in autonomia, senza dover passare da una figura che traduca le modifiche richieste aggiungendole a database manualmente. Questo processo inoltre astrae ulteriormente la struttura del database durante il processo di inserimento dei dati offrendo quindi flessibilità su modifiche future alla struttura. Un altro punto a favore della scelta di una SPA \vspace{5mm}

