\chapter{Strumenti e tecnologie}
\label{cha:intro}
\vspace{5mm}

\emph{Questo capitolo descrive in maniera più approfondita le tecnologie utilizzate nella prima e nella seconda versione in un confronto dettagliato.}

\section{Presentazioni delle tecnologie utilizzate in Open Air Museum}\vspace{5mm}
Filemaker: E’ una piattaforma per creare applicativi personalizzati votati alla categoria “gestionale” sviluppata da Apple. Open air museum utilizza questa tecnologia per creare l’interfaccia per la raccolta dati che verrà utilizzata da alcuni addetti comunali che appunto arricchiranno l’applicativo con i testi e i media provenienti da questo software. Tale applicativo è standalone e quindi slegato dall’applicativo lato server che espone le Api e l’importazione dei dati provenienti da questo applicativo deve essere fatta manualmente.\vspace{5mm}

	NodeJs: E’ come descritto in precedenza un runtime di Javascript al di fuori del browser. La particolarità di questa soluzione è che mette a disposizione una serie di Api a basso livello che permettono di utilizzare la scheda di rete e quindi di avviare server TCP e HTTP oltre che accesso al file system quindi lettura e scrittura su disco. In Open air museum questo framework è utilizzato per costruire il lato server ed esporre una serie di Api Http Rest che permettono la fruizione dei dati. Tutti i media, quindi audio e immagini vengono serviti anch’essi da questa piattaforma che oltre a questo gestisce anche l’autenticazione degli utenti e la gestione degli stessi.\vspace{5mm}

	Xcode: Ide per lo sviluppo IOS. L’applicativo per tale sistema operativo è stato sviluppato in Swift4.\vspace{5mm}

	Android Studio: Ide per lo sviluppo Android. L’applicativo per tale sistema operativo è stato sviluppato in Java per android.\vspace{5mm}

	MySql/SqLite: Sono le tecnologie che utilizzano i due database relazionali di cui il prodotto è fornito. Tutti i dati lato server sono contenuti in un database MySql che viene pilotato tramite l’applicativo lato server in Nodejs. Entrambi i database lato client utilizzano invece SqLite. Lo schema relazionale per il lato server è il seguente, si vedano gli allegati per i due schemi ER corrispondenti.

\section{Presentazione delle tecnologie utilizzabili in Alakai}\vspace{5mm}
React: Libreria Javascript per lo sviluppo di interfacce grafiche a componenti, permette lo sviluppo di single page application (SPA). In Alakai l’applicativo che permette l’inserimento dei dati e dei media oltre alle descrizioni dei punti di interesse e dei percorsi è creata utilizzando questa tecnologia sfruttando un set di Api che il lato server fornisce.\vspace{5mm}

	Redux: Libreria Javascript che permette di gestire lo stato applicativo come un unico oggetto statico, modificabile soltanto attraverso della azioni ben definite applicate ad esso. Questa tecnologia è utilizzata per gestire i dati che gli applicativi mobile recupereranno dal server in modo predittivo e sicuro.\vspace{5mm}\vspace{5mm}

	React-Native: Implementazione di React ma per l’ambiente nativo. Questa tecnologia verrà usata per creare l’interfaccia e la logica degli applicativi IOS e Android. Tale scelta infatti permette di condividere buona parte del codice tra le due piattaforme.\vspace{5mm}

	Express: Implementazione del pattern middleware per Node Js. Tale framework permette di gestire con granularità il routing delle Api e da la possibilità di centralizzare la gestione degli errori.\vspace{5mm}

	SqLite: “File-based” database utilizzato lato server per il salvataggio delle informazioni fornite dagli utenti admin attraverso l’applicativo web per la raccolta dei dati. Tale scelta è stata fatta per la flessibilità di questa tecnologia che permette di gestire internamente all’applicativo la creazione dello stesso e non attraverso una dipendenza esterna. Questo è stato fatto per semplificare ulteriormente il deploy eliminando le necessità di aggiungere una configurazione ulteriore all’ambiente.\vspace{5mm}
	
	\section{Confronto tra la nuova e la vecchia versione}\vspace{5mm}
	Confrontando gli stack delle due applicazioni in termini di tecnologie utilizzate possiamo vedere i motivi per cui le scelte fatte migliorano il software e sotto quali aspetti in particolare. \vspace{5mm}

La possibilità di condividere codice attraverso vari punti dello stack è fondamentale. In particolare grazie all’impiego di redux e del sua agnosticità intrinseca riguardo alla piattaforma utilizzata lo rende perfetto per questo esempio. In particolare tra l’applicativo admin sviluppato come webapp per il browser e gli applicativi nativi ho condiviso la totalità dell’implementazione gestendo lo store allo stesso modo mediante lo stesso codice. \vspace{5mm}

Le differenze principali sono su un altra parte e cioè la libreria che permette di interfacciarsi con le api. Seppur molti metodi sono condivisi, quelli relativi alla mutazione dei dati sono riservati ai soli utenti autenticati e cioè Admin. Tale peculiarità però non influisce nella possibilità di riutilizzare parte della libreria che implementa sia i metodi lato amministratore che quelli lato utente senza privilegi.\vspace{5mm} 

Un ulteriore punto è che rispetto alla versione precedente vi è una somiglianza molto forte tra quello che è l’applicativo web e l’applicativo nativo, le due applicazioni non sono compatibili ma condividono gran parte delle logiche e dei  pattern essendo di fatto lo stesso framework come si può vedere dalla foto 1a. \vspace{5mm}
	
La scelta dell’utilizzo di un database a file con la possibilità di configurare e passare ad un database “classico” si è rivelata molto importante per la scalabilità dell’applicativo. SqLite risulta più comodo in fase di deploy di contro, non ha le prestazioni di un database “classico” e la possibilità di configurare rapidamente la tecnologia da utilizzare è un plus importante. Questo si ottiene grazie all’impiego di un ORM in grado di fornire questa features come Sequelize. Oltre a questo permette di implementare in modo veloce migrazioni e seeder restando sempre agnostico sulla tecnologia a database. La versione precedente conteneva una pesante assunzione sull’utilizzo di un database MySql e ciò abbassava sostanzialmente la flessibilità e il riutilizzo del prodotto.\vspace{5mm}

Un altra differenza rispetto alla precedente è l’esistenza dell’applicativo admin in react che dovrà essere servito dall’applicativo server. Per fare questo è necessario che tutte le richieste non inviate direttamente a /api, vengano tutte reindirizzare all’applicativo in modo che la SPA utilizzi il router interno a React per mostrare i contenuti corrispondenti all’url della richiesta.\vspace{5mm}

Riguardo al lato “admin”, cioè quello che va a sostituire Filemaker nella raccolta dati, è stato sviluppato con React. La scelta di sviluppare una SPA per questo compito è stata dettata da un bisogno di rendere questa operazione iterabile e ripetibile. Nel caso in cui il cliente volesse cambiare dei testi o correggere delle traduzioni può farlo in autonomia, senza dover passare da una figura che traduca le modifiche richieste aggiungendole a database manualmente. Questo processo inoltre astrae ulteriormente la struttura del database durante il processo di inserimento dei dati offrendo quindi flessibilità su modifiche future alla struttura.\vspace{5mm}

\section{Lo stack della nuova versione}
Il refactor di Open Air Museum aveva due gol specifici. Il primo era quello di rendere il prodotto più mantenibile riducendo il numero di tecnologie e di conseguenza il numero di conoscenze necessarie e gestire il prodotto. Il secondo era quello di creare un prodotto molto meno specifico e più customizzabile per poter rivendere ad ulteriori enti o comuni. La prima specifica è stata resa possibile mediante appunto l’uso di una serie di tecnologie basate tutte su di un unico linguaggio in tutte le parti applicative. Tra le varie opzioni per l’app di raccolta dati si è optato di svilupparla mediante react. \vspace{5mm}

Da questo applicativo si possono gestire i vari punti di interesse, le operazioni che si possono fare sono la creazione, la modifica e l’eliminazione. L’utente può inoltre creare dei percorsi utilizzando i punti di interesse dando un ordine di percorrenza con un punto di partenza ed uno di arrivo. E’ possibile poi creare altri utenti che possono accedere come amministratori e modificare le proprie credenziali. La dashboard dell’applicativo permette inoltre di accedere ad una serie di dati anonimi sull’utilizzo come il numero di punti visitati, quali sono i percorsi con più seguiti e i punti con cui si è interagito di più.\vspace{5mm}

L’utilizzo di Javascript in tutto lo stack ha permesso, come era stato progettato, di poter condividere parte del codice tra più applicativi ed in particolare la libreria http che permette di consumare le api del server che oltre che mandare i dati sui vari punti e percorsi e i vari media, invia anche le impostazioni di configurazione delle due app. Queste impostazioni sono contenute in un file .json, il quale permette di gestire: la cartella di upload dei file, l’elenco delle lingue supportate, il dominio, l’utenza admin di default che viene creata al momento dell’avvio e le credenziali per collegare Eventbrite come sistema di ticketing di terze parti. Le impostazioni andranno poi a modificare alcune aree dell’applicativo, in particolare le lingue supportate andranno a cambiare il numero dei campi per ogni sezione testuale e ogni media (nome, descrizione, info e audio).\vspace{5mm}

Quindi passando all’applicativo per smartphone realizzato con React-native, le lingue che saranno disponibili all’utente saranno quelle indicate a lato server; l’utente infatti potrà cambiare la lingua a piacimento e tutto l’applicativo cambierà immediatamente contesto per adattarsi alla nuova lingua selezionata. Questo è possibile mediante redux che offre la funzionalità di ascolto delle mutazioni nello stato applicativo e quando l’azione di modifica lingua viene perpetrata esso avverte chi è in ascolto che ciò è avvenuto facendo adattate e ricaricare tutti i componenti di conseguenza. Questo tipo di funzionalità è molto facile da implementare con React e Redux mentre sarebbe più complessa dal punto di vista nativo. \vspace{5mm}

Questo è un esempio di come utilizzare tecnologie di questo tipo semplifica spesso la logica applicativa e di conseguenza anche la manutenibilità. Un altra funzionalità degli applicativi mobile è la funzionalità esplora che è stata sviluppata seguendo le features della versione precedente con l’aggiunta di un fallback su gps in caso di mancato supporto o configurazione di IBeacon assente. In particolare questa funzionalità permette, una volta attivata, di poter bloccare il telefono e ricevere una notifica nel momento in cui si passa in prossimità di un punto di interesse. La gestione della localizzazione in background viene gestita diversamente dai due sistemi operativi, mediante activity in Android e mediante una background task in IOS. \vspace{5mm}

Entrambe le metodologie richiamano dalla parte nativa del codice javascript che monitora la posizione dell’utente verificando o meno la posizione per poter indicare se si è in zona di un punto di interesse. Questa metodologia è utilizzata anche per la localizzazione tramite IBeacon ma con una struttura diversa. Si avvia una task in background che avvia una ricerca dei dispositivi IBeacon nelle vicinanze e ogniqualvolta uno o più Beacon sono trovati una task Javascript viene lanciata passando le informazioni sui bacon appena trovati. \vspace{5mm}

Un altro fattore di rilievo è stata la gestione della connettività. React-native fornisce l’Api Fetch, comune nei browser moderni, per eseguire richieste http. Sopra tale api è stata sviluppata un'interfaccia per sfruttare le Rest Api messe a disposizione dal server, attraverso questo canale è possibile richiedere i vari punti di interesse e i percorsi tradotti per la lingua in uso sul dispositivo. Dato che uno dei goal della nuova versione di Open Air Museum era quello di avere un applicativo “as a service” è imperativo che tutta la configurazione dell’applicativo venga gestita esternamente così da poter customizzare il più possibile questo prodotto senza dover modificare il sorgente. Tale goal è stato raggiunto costruendo l’applicativo attorno a dei parametri di configurazione inviati dal server che in questo modo controlla né alcuni dei comportamenti, come ad esempio la lista delle lingue supportate, le chiavi di accesso alle Api di Estimote (se si fa uso dell’ Estimote SDK) o l’utilizzo di un sistema di ticketing all’interno dei punti di interesse. Le uniche configurazioni necessarie e non removibili sono quelle legate al reame nativo, come il building delle due applicazioni e le chiavi di pubblicazione sui rispettivi store.\vspace{5mm}

Estraendo in questo modo la configurazione degli applicativi è stato possibile ottenere un prodotto flessibile e configurabile, rendendolo largamente più mantenibile di una controparte completamente nativa.\vspace{5mm}


